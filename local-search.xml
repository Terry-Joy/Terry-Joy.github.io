<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go基础学习_7</title>
    <link href="/2022/06/01/golang/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/learn_8/"/>
    <url>/2022/06/01/golang/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/learn_8/</url>
    
    <content type="html"><![CDATA[<h2 id="go语言并发"><a href="#go语言并发" class="headerlink" title="go语言并发"></a>go语言并发</h2><h3 id="Goroutine"><a href="#Goroutine" class="headerlink" title="Goroutine"></a>Goroutine</h3><p>Goroutine是Go程序中最基本的并发执行单元。每一个Go程序至少包含了一个main goroutine。Goroutine 是 Go 语言支持并发的核心，在一个Go程序中同时创建成百上千个goroutine是非常普遍的，一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。区别于操作系统线程由系统内核进行调度， goroutine 是由Go运行时（runtime）负责调度。</p><h4 id="go关键字"><a href="#go关键字" class="headerlink" title="go关键字"></a>go关键字</h4><p>使用goroutine很简单，在对应的函数和方法前面加上go关键字就可以创建一个goroutine了<br><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">go</span> f()<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><br>&#125;()匿名函数调用<br><br></code></pre></td></tr></table></figure></p><p>假如在main goroutine创建了一个默认的goroutine, 那么当main goroutine结束后，所有由 main goroutine 创建的 goroutine 也会一同退出。</p><p>示例<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> &#123;<br><span class="hljs-string">&quot;fmt&quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">go</span> hello()<br>fmt.Println(<span class="hljs-string">&quot;papa&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><br>我们发现hello语句并没有被打印出来，这是由于main goroutine执行完结束后，剩余的子Goroutine会退出。</p><h3 id="sync包的WaitGroup"><a href="#sync包的WaitGroup" class="headerlink" title="sync包的WaitGroup"></a>sync包的WaitGroup</h3><p>当你并不关心并发操作的结果或者有其它方式收集并发操作的结果时，WaitGroup是实现等待一组并发操作完成的好方法。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>wg.Done() <span class="hljs-comment">//告知当前goroutine完成</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(<span class="hljs-number">1</span>) <span class="hljs-comment">//登记1个goroutine</span><br><span class="hljs-keyword">go</span> hello()<br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>wg.Wait() <span class="hljs-comment">//阻塞等待登记的goroutine完成</span><br>&#125;<br></code></pre></td></tr></table></figure><br>可以利用这个同时启动多个Goroutine, 但是要注意这多个Goroutine之间无法确定启动顺序<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done() <span class="hljs-comment">//告知当前goroutine完成</span><br>fmt.Println(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> hello(i)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="动态栈"><a href="#动态栈" class="headerlink" title="动态栈"></a>动态栈</h3><p>Goroutine的初始栈空间很小（2KB）, 而实际上分配的空间是并不确定的，Go的runtime会自动为Goroutine分配合适的栈空间。</p><h3 id="Go-scheduler"><a href="#Go-scheduler" class="headerlink" title="Go scheduler"></a>Go scheduler</h3><p>Go的调度器采用的GPM调度模型</p><h3 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a>GOMAXPROCS</h3><p>go运行时的调度器使用GOMAXPROCS参数来确定需要使用多少个OS线程来执行Go代码，现在默认是全部的CPU逻辑核心数。</p><h2 id="channel"><a href="#channel" class="headerlink" title="channel"></a>channel</h2><p>现在很多都使用共享内存进行数据交换，但这种并发模型必须使用互斥量对内存进行加锁，这种做法会造成性能问题。go语言采用的并发模型是CSP, 通过通信共享内存而不是共享内存实现通信。</p><p>channel是goroutine之间的连接，使得一个goroutine可以发送特定值到另一个goroutine。<br>channel遵循先进先出的规则，保证收发数据的顺序。</p><p><strong>channel声明格式如下</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch1 <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>   <span class="hljs-comment">// 声明一个传递整型的通道</span><br><span class="hljs-keyword">var</span> ch2 <span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>  <span class="hljs-comment">// 声明一个传递布尔型的通道</span><br><span class="hljs-keyword">var</span> ch3 <span class="hljs-keyword">chan</span> []<span class="hljs-keyword">int</span> <span class="hljs-comment">// 声明一个传递int切片的通道</span><br></code></pre></td></tr></table></figure></p><p><strong>channel零值</strong><br>未初始化的通道类型变量其默认零值是$nil$<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>   <br>fmt.Println(ch)<br><br><span class="hljs-comment">//初始化</span><br>ch4 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">1</span>)<br><br>channel有发送、接收、关闭三种操作，发送和接收都使用&lt;-<br>初始化<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>发送<br>ch &lt;- <span class="hljs-number">10</span><br>接收<br>x := &lt;- ch<br>&lt;- ch <span class="hljs-comment">//从ch中接收值，忽略结果</span><br>关闭<br><span class="hljs-built_in">close</span>(ch)<br></code></pre></td></tr></table></figure></p><p>注意：一个通道值是可以被垃圾回收掉的。通道通常由发送方执行关闭操作，并且只有在接收方明确等待通道关闭的信号时才需要执行关闭操作。它和关闭文件不一样，通常在结束操作之后关闭文件是必须要做的，但关闭通道不是必须的。</p><p>关闭后的通道有以下特点：</p><ul><li>对一个关闭的通道再发送值就会导致 panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致 panic。</li></ul><h3 id="无缓冲通道"><a href="#无缓冲通道" class="headerlink" title="无缓冲通道"></a>无缓冲通道</h3><p>无缓冲通道又被称为阻塞通道。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>ch &lt;- <span class="hljs-number">10</span><br>fmt.Println(<span class="hljs-string">&quot;发送成功&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><br>执行该程序发现goroutine挂起死锁了，出现了deadlock错误。<br>问题在于无缓冲管道至少需要有一个接收方存在，否则会处于</p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>golang基础学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go基础学习_5</title>
    <link href="/2022/06/01/golang/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/learn_6/"/>
    <url>/2022/06/01/golang/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/learn_6/</url>
    
    <content type="html"><![CDATA[<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口可以看成是一种抽象类型，用于告诉”能做什么”的问题。</p><h3 id="接口定义"><a href="#接口定义" class="headerlink" title="接口定义"></a>接口定义</h3><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> nameer <span class="hljs-keyword">interface</span> &#123;<br>方法名<span class="hljs-number">1</span>(参数列表<span class="hljs-number">1</span>) 返回值列表<span class="hljs-number">1</span><br>&#125;<br>一般接口类型后面会带er，比如writer, closer。<br>当方法名和接口名首字母都是大写的时候，这个方法可以被接口所在之外的代码访问。<br></code></pre></td></tr></table></figure><h3 id="实现接口的条件"><a href="#实现接口的条件" class="headerlink" title="实现接口的条件"></a>实现接口的条件</h3><p>接口本质上就是规定了<strong>需要实现的方法列表</strong>，若一个类型实现了接口中规定的所有方法，我们就称它实现了这个接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> writer <span class="hljs-keyword">interface</span> &#123;<br>write()<br>&#125;<br><span class="hljs-keyword">type</span> P <span class="hljs-keyword">struct</span> &#123;<br><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p P)</span> <span class="hljs-title">write</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>接口其实和c++中的多态有点相似，一个接口，多种方法，当我们遇到这样的需求的时候，可以使用接口实现，减少代码冗余。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go">所有类型都有一个say的方法。这样我们可以定义一个对应的接口<br><span class="hljs-keyword">type</span> Sayer <span class="hljs-keyword">interface</span> &#123;<br>Say()<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MakeHungry</span><span class="hljs-params">(s Sayer)</span></span> &#123;<br>s.Say()<br>&#125;<br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Cat)</span> <span class="hljs-title">Say</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;喵喵喵~&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">Say</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;汪汪汪~&quot;</span>)<br>&#125;<br><br>实现了接口类型的变量后，一个接口类型变量能存储所有实现该接口的类型变量<br><span class="hljs-keyword">var</span> x Sayer <br>a := Cat&#123;&#125;<br>b := Dog &#123;&#125;<br>x = a<br>x.Say()<br>x = b<br>x.Say()<br></code></pre></td></tr></table></figure><p><strong>值接收者和指针接收者</strong><br>对于某个固定的接口，我们使用不同类型实现该接口，使用值接收者实现接口之后，不管是结构体类型还是对应的结构体指针类型的变量都可以赋值给该接口变量。假如使用指针求值，则结构体类型不能直接赋值。</p><p><strong>一个类型可以实现多个接口</strong><br>比如对于Sayer和writer可以分开实现且不影响。</p><p><strong>多种类型可以实现同一接口</strong><br>比如人可以move, 狗也可以move</p><p>接口的所有方法不一定完全由某一类型实现，可以通过在类型中嵌入其他类型或结构体实现。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// WashingMachine 洗衣机</span><br><span class="hljs-keyword">type</span> WashingMachine <span class="hljs-keyword">interface</span> &#123;<br>wash()<br>dry()<br>&#125;<br><br><span class="hljs-comment">// 甩干器</span><br><span class="hljs-keyword">type</span> dryer <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// 实现WashingMachine接口的dry()方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dryer)</span> <span class="hljs-title">dry</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;甩一甩&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 海尔洗衣机</span><br><span class="hljs-keyword">type</span> haier <span class="hljs-keyword">struct</span> &#123;<br>dryer <span class="hljs-comment">//嵌入甩干器</span><br>&#125;<br><br><span class="hljs-comment">// 实现WashingMachine接口的wash()方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h haier)</span> <span class="hljs-title">wash</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;洗刷刷&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="接口组合"><a href="#接口组合" class="headerlink" title="接口组合"></a>接口组合</h3><p>接口与接口之间可以通过互相嵌套形成新的接口类型，例如go标准库io源码中就有很多接口之间互相组合的例子。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;<br>Read(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)<br>&#125;<br><br><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;<br>Write(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)<br>&#125;<br><br><span class="hljs-keyword">type</span> Closer <span class="hljs-keyword">interface</span> &#123;<br>Close() error<br>&#125;<br><br><span class="hljs-comment">// ReadWriter 是组合Reader接口和Writer接口形成的新接口类型</span><br><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;<br>Reader<br>Writer<br>&#125;<br><br><span class="hljs-comment">// ReadCloser 是组合Reader接口和Closer接口形成的新接口类型</span><br><span class="hljs-keyword">type</span> ReadCloser <span class="hljs-keyword">interface</span> &#123;<br>Reader<br>Closer<br>&#125;<br><br><span class="hljs-comment">// WriteCloser 是组合Writer接口和Closer接口形成的新接口类型</span><br><span class="hljs-keyword">type</span> WriteCloser <span class="hljs-keyword">interface</span> &#123;<br>Writer<br>Closer<br>&#125;<br></code></pre></td></tr></table></figure><p>对于多种接口组合形成的新接口类型，同样只需要实现新接口类型中规定的所有方法就算实现了该接口类型。</p><h3 id="空接口"><a href="#空接口" class="headerlink" title="空接口"></a>空接口</h3><p><strong>空接口可以用于实现泛型</strong></p><p>空接口指没有定义任何方法的接口类型，所以任何类型都可以视为实现了空接口，因此，空接口类型的变量可以用于存储任意类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//可以接收任意类型的函数参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">show</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">//作为map的值，存储任意值的字典。</span><br><span class="hljs-keyword">var</span> x = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><h3 id="接口值"><a href="#接口值" class="headerlink" title="接口值"></a>接口值</h3><p>我们把接口类型看成是抽象类型，接口值实际上是由两个部分组成，实现该接口的类型和值。</p><p><strong>我们不能对空接口值调用任何方法，否则会产生panic</strong></p><p>我们要注意，接口值进行比较的时候必须满足接口的动态类型和动态值都相等的时候才相等。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">x Mover = <span class="hljs-built_in">new</span>(Dog)<br>y Mover = <span class="hljs-built_in">new</span>(Car)<br><span class="hljs-comment">//x != y</span><br><br>同时，若接口值的动态类型相同，但不支持比较，比较的时候会引发<span class="hljs-built_in">panic</span>。<br></code></pre></td></tr></table></figure><h3 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go">我们可以借助标准库fmt包的格式化打印获取到接口值的动态类型。<br><span class="hljs-keyword">var</span> x Mover<br>m = &amp;Dog&#123;Name: <span class="hljs-string">&quot;旺财&quot;</span>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, m)<br><br><span class="hljs-keyword">go</span>支持类型断言<br>v, ok = name.(T) <span class="hljs-comment">//ok表示是否为对应的值</span><br><span class="hljs-keyword">if</span> ok &#123;<br><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><br>&#125;<br><br>可以通过<span class="hljs-keyword">switch</span>语句判断一个接口值的多个类型。<br><br><span class="hljs-comment">// justifyType 对传入的空接口类型变量x进行类型断言</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">justifyType</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">switch</span> v := x.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">string</span>:<br>fmt.Printf(<span class="hljs-string">&quot;x is a string，value is %v\n&quot;</span>, v)<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>:<br>fmt.Printf(<span class="hljs-string">&quot;x is a int is %v\n&quot;</span>, v)<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">bool</span>:<br>fmt.Printf(<span class="hljs-string">&quot;x is a bool is %v\n&quot;</span>, v)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;unsupport type！&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>接口总的来说是一种抽象类型，可以看成是多态的一种实现方法，能帮我们隐藏某个功能的具体实现，但是我们不能盲目使用接口，不要为了使用接口类型而增加不必要的抽象，只有当多个具体类型以相同方式进行处理时才需要定义接口。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>golang基础学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go基础学习_6</title>
    <link href="/2022/06/01/golang/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/learn_7/"/>
    <url>/2022/06/01/golang/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/learn_7/</url>
    
    <content type="html"><![CDATA[<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射指程序运行期间对程序本身进行访问、检测和修改的能力。支持反射的语言可以在程序编译期将<strong>变量的反射信息，如字段名称、类型信息、结构体信息</strong>等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p><p>go使用reflect包访问程序的反射信息。</p><p>我们可以使用reflect中的TypeOf和ValueOf来获取任意对象的Value和Type</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><pre><code class="hljs go">reflect.TypeOf()可以获取值的类型对象<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">F</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>a := reflect.TypeOf(x)<br>fmt.Println(<span class="hljs-string">&quot;type&quot;</span>, a)<br>&#125;<br></code></pre></td></tr></table></figure><p><br/></p><h3 id="type-name和type-kind"><a href="#type-name和type-kind" class="headerlink" title="type name和type  kind"></a>type name和type  kind</h3><p>反射中其实分为type和kind，kind指底层的类型，在反射中，当需要区分指针、结构体等大品种类型，就会用kind。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectType</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>t := reflect.TypeOf(x)<br>fmt.Printf(<span class="hljs-string">&quot;type:%v kind:%v\n&quot;</span>, t.Name(), t.Kind())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a *<span class="hljs-keyword">float32</span> <span class="hljs-comment">// 指针</span><br><span class="hljs-keyword">var</span> b myInt    <span class="hljs-comment">// 自定义类型</span><br><span class="hljs-keyword">var</span> c <span class="hljs-keyword">rune</span>     <span class="hljs-comment">// 类型别名</span><br>reflectType(a) <span class="hljs-comment">// type: kind:ptr</span><br>reflectType(b) <span class="hljs-comment">// type:myInt kind:int64</span><br>reflectType(c) <span class="hljs-comment">// type:int32 kind:int32</span><br><br><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>age  <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-keyword">type</span> book <span class="hljs-keyword">struct</span>&#123; title <span class="hljs-keyword">string</span> &#125;<br><span class="hljs-keyword">var</span> d = person&#123;<br>name: <span class="hljs-string">&quot;沙河小王子&quot;</span>,<br>age:  <span class="hljs-number">18</span>,<br>&#125;<br><span class="hljs-keyword">var</span> e = book&#123;title: <span class="hljs-string">&quot;《跟小王子学Go语言》&quot;</span>&#125;<br>reflectType(d) <span class="hljs-comment">// type:person kind:struct</span><br>reflectType(e) <span class="hljs-comment">// type:book kind:struct</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>对于go的反射来说，数组、切片、map和指针等类型变量，他们的.name返回空</strong></p><p>下面是reflect包的kind类型<br>，我们可以发现基本底层类型都覆盖了<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Kind <span class="hljs-keyword">uint</span><br><span class="hljs-keyword">const</span> (<br>    Invalid Kind = <span class="hljs-literal">iota</span>  <span class="hljs-comment">// 非法类型</span><br>    Bool                 <span class="hljs-comment">// 布尔型</span><br>    Int                  <span class="hljs-comment">// 有符号整型</span><br>    Int8                 <span class="hljs-comment">// 有符号8位整型</span><br>    Int16                <span class="hljs-comment">// 有符号16位整型</span><br>    Int32                <span class="hljs-comment">// 有符号32位整型</span><br>    Int64                <span class="hljs-comment">// 有符号64位整型</span><br>    Uint                 <span class="hljs-comment">// 无符号整型</span><br>    Uint8                <span class="hljs-comment">// 无符号8位整型</span><br>    Uint16               <span class="hljs-comment">// 无符号16位整型</span><br>    Uint32               <span class="hljs-comment">// 无符号32位整型</span><br>    Uint64               <span class="hljs-comment">// 无符号64位整型</span><br>    Uintptr              <span class="hljs-comment">// 指针</span><br>    Float32              <span class="hljs-comment">// 单精度浮点数</span><br>    Float64              <span class="hljs-comment">// 双精度浮点数</span><br>    Complex64            <span class="hljs-comment">// 64位复数类型</span><br>    Complex128           <span class="hljs-comment">// 128位复数类型</span><br>    Array                <span class="hljs-comment">// 数组</span><br>    Chan                 <span class="hljs-comment">// 通道</span><br>    Func                 <span class="hljs-comment">// 函数</span><br>    Interface            <span class="hljs-comment">// 接口</span><br>    Map                  <span class="hljs-comment">// 映射</span><br>    Ptr                  <span class="hljs-comment">// 指针</span><br>    Slice                <span class="hljs-comment">// 切片</span><br>    String               <span class="hljs-comment">// 字符串</span><br>    Struct               <span class="hljs-comment">// 结构体</span><br>    UnsafePointer        <span class="hljs-comment">// 底层指针</span><br>)<br></code></pre></td></tr></table></figure></p><h3 id="Value-of"><a href="#Value-of" class="headerlink" title="Value of"></a>Value of</h3><p><strong>reflect.ValeuOf返回的是reflect.Value类型</strong>，包含了原始的值信息，我们可以通过reflect.Value类型提供的获取原始值的方法获取值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectValue</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>v := reflect.ValueOf(x)<br>k := v.Kind()<br><span class="hljs-keyword">switch</span> k &#123;<br><span class="hljs-keyword">case</span> reflect.Int64:<br><span class="hljs-comment">// v.Int()从反射中获取整型的原始值，然后通过int64()强制类型转换</span><br>fmt.Printf(<span class="hljs-string">&quot;type is int64, value is %d\n&quot;</span>, <span class="hljs-keyword">int64</span>(v.Int()))<br><span class="hljs-keyword">case</span> reflect.Float32:<br><span class="hljs-comment">// v.Float()从反射中获取浮点型的原始值，然后通过float32()强制类型转换</span><br>fmt.Printf(<span class="hljs-string">&quot;type is float32, value is %f\n&quot;</span>, <span class="hljs-keyword">float32</span>(v.Float()))<br><span class="hljs-keyword">case</span> reflect.Float64:<br><span class="hljs-comment">// v.Float()从反射中获取浮点型的原始值，然后通过float64()强制类型转换</span><br>fmt.Printf(<span class="hljs-string">&quot;type is float64, value is %f\n&quot;</span>, <span class="hljs-keyword">float64</span>(v.Float()))<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">float32</span> = <span class="hljs-number">3.14</span><br><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int64</span> = <span class="hljs-number">100</span><br>reflectValue(a) <span class="hljs-comment">// type is float32, value is 3.140000</span><br>reflectValue(b) <span class="hljs-comment">// type is int64, value is 100</span><br><span class="hljs-comment">// 将int类型的原始值转换为reflect.Value类型</span><br>c := reflect.ValueOf(<span class="hljs-number">10</span>)<br>fmt.Printf(<span class="hljs-string">&quot;type c :%T\n&quot;</span>, c) <span class="hljs-comment">// type c :reflect.Value</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="通过反射设置变量的值"><a href="#通过反射设置变量的值" class="headerlink" title="通过反射设置变量的值"></a>通过反射设置变量的值</h3><p>想要在函数中通过反射修改变量的值，需要传递变量地址才能修改相应的值，但是我们可以通过reflect的Elem()方法来获取指针对应的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;reflect&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ref1</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>a := reflect.ValueOf(x)<br><span class="hljs-keyword">if</span> a.Elem().Kind() == reflect.Int64 &#123;<span class="hljs-comment">//通过Elem()可以获取指针对应的值</span><br>a.Elem().SetInt(<span class="hljs-number">200</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ref2</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>a := reflect.ValueOf(x)<br><span class="hljs-keyword">if</span> a.Kind() == reflect.Int64 &#123;<br>a.SetInt(<span class="hljs-number">200</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int64</span> = <span class="hljs-number">10</span><br><span class="hljs-comment">//ref2(a) 报错，using unaddressable value</span><br>ref1(&amp;a) <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="isNil-和isValid"><a href="#isNil-和isValid" class="headerlink" title="isNil()和isValid()"></a>isNil()和isValid()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span> <span class="hljs-title">IsNil</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span><br></code></pre></td></tr></table></figure><p>IsNil()报告v持有的值是否为nil。v持有的值的分类必须是通道、函数、接口、映射、指针、切片之一；否则IsNil函数会导致panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Value)</span> <span class="hljs-title">IsValid</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span><br></code></pre></td></tr></table></figure><p>IsValid()返回v是否持有一个值，当v是零值时候返回假，此时除了IsValid(), String, Kind之外的方法都会导致panic</p><p>我们一般使用Isnil()来判断指针是否为空，IsValid()用于判定返回值是否有效<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// *int类型空指针</span><br><span class="hljs-keyword">var</span> a *<span class="hljs-keyword">int</span><br>fmt.Println(<span class="hljs-string">&quot;var a *int IsNil:&quot;</span>, reflect.ValueOf(a).IsNil())<br><span class="hljs-comment">// nil值</span><br>fmt.Println(<span class="hljs-string">&quot;nil IsValid:&quot;</span>, reflect.ValueOf(<span class="hljs-literal">nil</span>).IsValid())<br><span class="hljs-comment">// 实例化一个匿名结构体</span><br>b := <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-comment">// 尝试从结构体中查找&quot;abc&quot;字段</span><br>fmt.Println(<span class="hljs-string">&quot;不存在的结构体成员:&quot;</span>, reflect.ValueOf(b).FieldByName(<span class="hljs-string">&quot;abc&quot;</span>).IsValid())<br><span class="hljs-comment">// 尝试从结构体中查找&quot;abc&quot;方法</span><br>fmt.Println(<span class="hljs-string">&quot;不存在的结构体方法:&quot;</span>, reflect.ValueOf(b).MethodByName(<span class="hljs-string">&quot;abc&quot;</span>).IsValid())<br><span class="hljs-comment">// map</span><br>c := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>&#123;&#125;<br><span class="hljs-comment">// 尝试从map中查找一个不存在的键</span><br>fmt.Println(<span class="hljs-string">&quot;map中不存在的键：&quot;</span>, reflect.ValueOf(c).MapIndex(reflect.ValueOf(<span class="hljs-string">&quot;娜扎&quot;</span>)).IsValid())<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="结构体反射"><a href="#结构体反射" class="headerlink" title="结构体反射"></a>结构体反射</h3><p>任意值通过$reflect.TypeOf()$获得反射对象的信息后，如果类型是结构体，可以通过reflect.Type的方法获取与结构体成员相关的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">Field(i <span class="hljs-keyword">int</span>) StructField根据索引，返回索引对应的结构体字段的信息。<br>NumField() <span class="hljs-keyword">int</span> 返回结构体成员字段数量。<br>FieldByName(name <span class="hljs-keyword">string</span>) (StructField, <span class="hljs-keyword">bool</span>)根据给定字符串返回字符串对应的结构体字段的信息。<br>FieldByIndex(index []<span class="hljs-keyword">int</span>) StructField多层成员访问时，根据 []<span class="hljs-keyword">int</span> 提供的每个结构体的字段索引，返回字段的信息。<br>FieldByNameFunc(match <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span>) <span class="hljs-params">(StructField,<span class="hljs-keyword">bool</span>)</span>根据传入的匹配函数匹配需要的字段。</span><br>NumMethod() <span class="hljs-keyword">int</span>返回该类型的方法集中方法的数目<br>Method(<span class="hljs-keyword">int</span>) Method返回该类型方法集中的第i个方法<br>MethodByName(<span class="hljs-keyword">string</span>)(Method, <span class="hljs-keyword">bool</span>)根据方法名返回该类型方法集中的方法<br></code></pre></td></tr></table></figure><h3 id="struct-Field类型"><a href="#struct-Field类型" class="headerlink" title="struct Field类型"></a>struct Field类型</h3><p>StructField类型用来描述结构体中的一个字段的信息。定义如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StructField <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&quot;&quot;。</span><br>    <span class="hljs-comment">// 参见http://golang.org/ref/spec#Uniqueness_of_identifiers</span><br>    Name    <span class="hljs-keyword">string</span><br>    PkgPath <span class="hljs-keyword">string</span><br>    Type      Type      <span class="hljs-comment">// 字段的类型</span><br>    Tag       StructTag <span class="hljs-comment">// 字段的标签</span><br>    Offset    <span class="hljs-keyword">uintptr</span>   <span class="hljs-comment">// 字段在结构体中的字节偏移量</span><br>    Index     []<span class="hljs-keyword">int</span>     <span class="hljs-comment">// 用于Type.FieldByIndex时的索引切片</span><br>    Anonymous <span class="hljs-keyword">bool</span>      <span class="hljs-comment">// 是否匿名字段</span><br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go">结构体反射使用示例<br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> P <span class="hljs-keyword">struct</span> &#123;<br>x <span class="hljs-keyword">int</span> <span class="hljs-string">`json: &quot;file&quot;`</span><br>y <span class="hljs-keyword">int</span> <span class="hljs-string">`json: &quot;score&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>point := P&#123;x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>&#125;<br>t := reflect.TypeOf(point)<br>fmt.Println(t.Name(), t.Kind())<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; t.NumField(); i++ &#123;<br>f := t.Field(i)<br>fmt.Printf(<span class="hljs-string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, f.Name, f.Index, f.Type, f.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>))<br>&#125;<br><br><span class="hljs-keyword">if</span> f, ok := t.FieldByName(<span class="hljs-string">&quot;x&quot;</span>); ok &#123;<br>fmt.Printf(<span class="hljs-string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, f.Name, f.Index, f.Type, f.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>))<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>反射的坏处</p><ul><li>基于反射的代码是极其脆弱的，反射中的类型错误会在真正运行的时候才会引发panic，那很可能是在代码写完的很长时间之后。</li><li>大量使用反射的代码通常难以理解。</li><li>反射的性能低下，基于反射实现的代码通常比正常代码运行速度慢一到两个数量级。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>golang基础学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go基础学习_ 4</title>
    <link href="/2022/05/05/golang/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/learn_4/"/>
    <url>/2022/05/05/golang/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/learn_4/</url>
    
    <content type="html"><![CDATA[<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>go里面的指针和c差别在于他是安全指针，无法进行偏移和运算，其他差不多。</p><p>里面的指针类型是形如*int这种的。</p><p>注意在使用一个指针指向的值时候应该先初始化指针指向的空间</p><p>var a* int</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-built_in">new</span>和<span class="hljs-built_in">make</span>都可以用于分配内存<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">new</span><span class="hljs-params">(Type)</span> *<span class="hljs-title">Type</span></span><br><br><span class="hljs-built_in">make</span>区别于<span class="hljs-built_in">new</span>的地方在于slice, <span class="hljs-keyword">map</span>以及<span class="hljs-keyword">chan</span>的内存创建<br></code></pre></td></tr></table></figure><h2 id="类型别名和自定义类型"><a href="#类型别名和自定义类型" class="headerlink" title="类型别名和自定义类型"></a>类型别名和自定义类型</h2><p>type TypeAlias = Type</p><p>这是一种定义新类型的方法，具有int对应的特性。<br>type MyInt int </p><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>city <span class="hljs-keyword">string</span><br>age <span class="hljs-keyword">int8</span><br>&#125;<br><br>实例化<br><span class="hljs-keyword">var</span> person x1<br>x1.name = xx<br><br>匿名结构体<br><span class="hljs-keyword">var</span> user <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-keyword">string</span>; Age <span class="hljs-keyword">int</span>&#125;<br>user.Name = <span class="hljs-string">&quot;&quot;</span><br>user.Age = <span class="hljs-number">18</span><br><br>使用<span class="hljs-built_in">new</span>对结构体实例化<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-built_in">new</span>(person)<br>注意对于指针和对象，都是直接用.来修改和使用成员<br>p2.name = xx<br><br>通过&amp;对结构体取地址相当于对该结构体类型进行了一次<span class="hljs-built_in">new</span>实例操作<br>p3 := &amp;person&#123;&#125;<br>p3.name = <span class="hljs-string">&quot;&quot;</span><br>p3.age = xx<br></code></pre></td></tr></table></figure><h3 id="结构体初始化"><a href="#结构体初始化" class="headerlink" title="结构体初始化"></a>结构体初始化</h3><p>未初始化的结构体，成员变量都是对应其类型的零值。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go">使用键值对初始化<br><br>p5 := person&#123;<br>name: <span class="hljs-string">&quot;小王子&quot;</span>,<br>city: <span class="hljs-string">&quot;北京&quot;</span>,<br>age:  <span class="hljs-number">18</span>,<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;p5=%#v\n&quot;</span>, p5)<br><br>结构体指针也可以进行键值对初始化<br>p6 := &amp;person&#123;<br>name: <span class="hljs-string">&quot;小王子&quot;</span>,<br>city: <span class="hljs-string">&quot;北京&quot;</span>,<br>age:  <span class="hljs-number">18</span>,<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;p6=%#v\n&quot;</span>, p6)<br>不写初始值默认是该字段的零值<br><br>使用值的列表初始化<br>p8 := &amp;person&#123;<br><span class="hljs-string">&quot;沙河娜扎&quot;</span>,<br><span class="hljs-string">&quot;北京&quot;</span>,<br><span class="hljs-number">28</span>,<br>&#125;<br>注意这种方式<br><span class="hljs-number">1.</span> 必须初始化结构体的所有字段。<br><span class="hljs-number">2.</span> 初始值的填充顺序必须与字段在结构体中的声明顺序一致。<br><span class="hljs-number">3.</span> 该方式不能和键值初始化方式混用。<br></code></pre></td></tr></table></figure></p><p><br><br><br/><br>结构体的内存布局</p><p><strong>空结构体不占用内存</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">自定义构造函数<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newStudent</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, age <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">student</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;student&#123;name: name, age: age&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f1 := newStudent(<span class="hljs-string">&quot;人&quot;</span>, <span class="hljs-number">90</span>)<br>fmt.Println(f1)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h3><p>接收者可以看成是cpp中this对象，即确定对应的调用对象。</p><ul><li>指针类型，会实际修改对应的值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(name * <span class="hljs-keyword">type</span>)</span> <span class="hljs-title">functionName</span><span class="hljs-params">(params ...)</span></span> &#123;<br><br>&#125;<br><br>若使用值类型，则无法修改对应的值<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(name <span class="hljs-keyword">type</span>)</span> <span class="hljs-title">functionName</span><span class="hljs-params">(params ...)</span></span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>一般使用指针类型的接收者，主要是需要修改接收者的值，拷贝的为较大的对象</p><p><strong>实际上go中可以为任意类型添加方法</strong>。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-keyword">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MyInt)</span> <span class="hljs-title">SayHello</span><span class="hljs-params">()</span></span> &#123;<br><br>&#125;<br><span class="hljs-keyword">var</span> xx MyInt    <br>xx.SayHello()<br></code></pre></td></tr></table></figure><br><strong>非本地类型不能定义方法，所以我们不能给别的包的类型定义方法。</strong></p><h3 id="嵌套结构体"><a href="#嵌套结构体" class="headerlink" title="嵌套结构体"></a>嵌套结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> XX <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-keyword">string</span><br>&#125;<br><span class="hljs-keyword">type</span> YY <span class="hljs-keyword">struct</span> &#123;<br>a XX<br>&#125;<br><br>注意如果在结构体内部没有声明变量的名字，可以看成是以类型名作为变量名。<br></code></pre></td></tr></table></figure><h3 id="结构体字段的可见性"><a href="#结构体字段的可见性" class="headerlink" title="结构体字段的可见性"></a>结构体字段的可见性</h3><p>大写字母表示可公开访问，小写表示私有</p><h3 id="结构体与json序列化"><a href="#结构体与json序列化" class="headerlink" title="结构体与json序列化"></a>结构体与json序列化</h3><p>我们可以将结构体转为json字符串，也可以将json字符串转为结构体。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">data, err := json.Marshal(c)<br>err := json.Unmarshal([]<span class="hljs-keyword">byte</span>(str), c1)<br></code></pre></td></tr></table></figure></p><p><strong>注意对于传参是slice, map时，是引用类型，传参的时候需要注意修改问题。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>golang基础学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go基础学习_3</title>
    <link href="/2022/05/05/golang/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/learn_3/"/>
    <url>/2022/05/05/golang/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/learn_3/</url>
    
    <content type="html"><![CDATA[<h2 id="function"><a href="#function" class="headerlink" title="function"></a>function</h2><p>go语言中支持函数、匿名函数和闭包，且函数在go中属于一等公民</p><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><pre><code class="hljs go">注意函数参数<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(x <span class="hljs-keyword">int32</span>, y <span class="hljs-keyword">int32</span>)</span> <span class="hljs-title">int32</span></span> &#123;<br><span class="hljs-keyword">return</span> x + y<br>&#125;<br><br>函数的参数中如果相邻变量的类型相同，则可以省略类型<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">intSum</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> x + y<br>&#125;<br><br><br>可变参数只能放在函数的最后位置<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">intSum2</span><span class="hljs-params">(x ...<span class="hljs-keyword">int</span>)</span><span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span>(x) &#123;<br><br>&#125;<span class="hljs-comment">//本质上是通过切片实现的</span><br>&#125;<br>可以传入多个参数<br><br>可以使用多返回值<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cal</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">return</span> suma, sumb<br>&#125;<br><br>函数定义时可以给返回值命名，并在函数体中直接使用这些变量，最后通过<span class="hljs-keyword">return</span>关键字返回<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(sum, sub <span class="hljs-keyword">int</span>)</span></span> &#123;<br>sum = x + y<br>sub = x - y<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="函数进阶"><a href="#函数进阶" class="headerlink" title="函数进阶"></a>函数进阶</h2><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>和cpp一致，不讲</p><h3 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> name <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> x + y<br>&#125;<br><br><span class="hljs-keyword">var</span> x <span class="hljs-keyword">type</span><br>x = add<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> c <span class="hljs-keyword">type</span><br>c = add<br><br><span class="hljs-comment">//将函数add赋值给变量</span><br>f := add<br>fmt.Println(f(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>（1）函数可以作为参数<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>, op <span class="hljs-keyword">func</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span>) <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> op(x, y)<br>&#125;<br><br><span class="hljs-comment">//传入函数作为参数</span><br>a := add(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, cal)<br></code></pre></td></tr></table></figure><br>（2）函数可以作为返回值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">do</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">func</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span>, <span class="hljs-title">error</span>)</span> &#123;<br><span class="hljs-keyword">switch</span> s &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;+&quot;</span>:<br><span class="hljs-keyword">return</span> add, <span class="hljs-literal">nil</span><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;-&quot;</span>:<br><span class="hljs-keyword">return</span> sub, <span class="hljs-literal">nil</span><br><span class="hljs-keyword">default</span>:<br>err := errors.New(<span class="hljs-string">&quot;无法识别的操作符&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(参数)</span><span class="hljs-params">(返回值)</span></span> &#123;<br><br>&#125;<br><br><span class="hljs-comment">// 将匿名函数保存到变量</span><br>add := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span></span> &#123;<br>fmt.Println(x + y)<br>&#125;<br>add(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) <span class="hljs-comment">// 通过变量调用匿名函数</span><br><br><span class="hljs-comment">//自执行函数：匿名函数定义完加()直接执行</span><br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span></span> &#123;<br>fmt.Println(x + y)<br>&#125;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br></code></pre></td></tr></table></figure><p><strong>匿名函数多用于实现回调函数和闭包, 可以作为返回值</strong></p><p>Go语言中只存在值传递（要么是该值的副本，要么是指针的副本），不存在引用传递。之所以对于引用类型的传递可以修改原内容数据，是因为在底层默认使用该引用类型的指针进行传递，但是也是使用指针的副本，依旧是值传递。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包指的是一个函数和与其相关的引用环境组合而成的实体。简单来说，闭包=函数+引用环境。 </p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-keyword">int</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>x += y<br><span class="hljs-keyword">return</span> x<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> f = adder()<br>fmt.Println(f(<span class="hljs-number">10</span>)) <span class="hljs-comment">//10</span><br>fmt.Println(f(<span class="hljs-number">20</span>)) <span class="hljs-comment">//30</span><br>fmt.Println(f(<span class="hljs-number">30</span>)) <span class="hljs-comment">//60</span><br><br>f1 := adder()<br>fmt.Println(f1(<span class="hljs-number">40</span>)) <span class="hljs-comment">//40</span><br>fmt.Println(f1(<span class="hljs-number">50</span>)) <span class="hljs-comment">//90</span><br>&#125;<br>我们发现f就是一个闭包，在f的生命周期内，变量x也一直有效。<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(base <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">func</span>(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span>, <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span>)</span> &#123;<br>add := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>base += i<br><span class="hljs-keyword">return</span> base<br>&#125;<br><br>sub := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>base -= i<br><span class="hljs-keyword">return</span> base<br>&#125;<br><span class="hljs-keyword">return</span> add, sub<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f1, f2 := calc(<span class="hljs-number">10</span>)<br>fmt.Println(f1(<span class="hljs-number">1</span>), f2(<span class="hljs-number">2</span>)) <span class="hljs-comment">//11 9</span><br>fmt.Println(f1(<span class="hljs-number">3</span>), f2(<span class="hljs-number">4</span>)) <span class="hljs-comment">//12 8</span><br>fmt.Println(f1(<span class="hljs-number">5</span>), f2(<span class="hljs-number">6</span>)) <span class="hljs-comment">//13 7</span><br>&#125;<br>在闭包内部，所有的变量会与闭包的生命周期共存.<br></code></pre></td></tr></table></figure><h3 id="defer语句"><a href="#defer语句" class="headerlink" title="defer语句"></a>defer语句</h3><p>go里面的defer语句会将跟随在其后的语句延迟处理。在$defer$归属的函数即将返回时，再将defer定义的逆序进行，用于资源清理、文件关闭、解锁及记录时间等。</p><p><strong>go的return并非原子操作，分为2部分，给返回值赋值和RET指令两步，defer语句执行的时机就在给返回值复制后。</strong><br>可以看成是 返回值 = x, defer, return</p><p>注意defer有几个重要特性。</p><ul><li><p>defer被声明的时候，参数会被实时解析</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> &#123;<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">defer</span> fmt.Println(i) <span class="hljs-comment">//此时解析为0</span><br>i++<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>defer的执行是先进后出</p></li><li>defer可以读取有名返回值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">c</span><span class="hljs-params">()</span> <span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; i++ &#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>&#125;<br>这里输出为<span class="hljs-number">2</span>。<br></code></pre></td></tr></table></figure></li></ul><p>最后大家可以看一下下面四个的输出，如果能彻底理解了，就问题不大了。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f1</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>x := <span class="hljs-number">5</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>x++<br>&#125;()<br><span class="hljs-keyword">return</span> x<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">()</span> <span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>x++<br>&#125;()<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">()</span> <span class="hljs-params">(y <span class="hljs-keyword">int</span>)</span></span> &#123;<br>x := <span class="hljs-number">5</span><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>x++<br>&#125;()<br><span class="hljs-keyword">return</span> x<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f4</span><span class="hljs-params">()</span> <span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span> &#123;<br>x++<br>&#125;(x)<br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(f1())<br>fmt.Println(f2())<br>fmt.Println(f3())<br>fmt.Println(f4())<br>&#125;<br>输出是<span class="hljs-number">5655</span><br>浅析一下<br>f1:<br>r := x = <span class="hljs-number">5</span><br>x++<br><span class="hljs-keyword">return</span> r<br><br>f2:<br>x = <span class="hljs-number">5</span><br>x++<br><span class="hljs-keyword">return</span> x<br><br>f3:<br>y := x = <span class="hljs-number">5</span><br>x++<br><span class="hljs-keyword">return</span> y<br><br>f4:<br>外层x = <span class="hljs-number">5</span><br>内层refer传参的x副本 = <span class="hljs-number">6</span><br><span class="hljs-keyword">return</span> 外层x<br></code></pre></td></tr></table></figure></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">再来一个简单的面试题<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(index <span class="hljs-keyword">string</span>, a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>ret := a + b<br>fmt.Println(index, a, b, ret)<br><span class="hljs-keyword">return</span> ret<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>x := <span class="hljs-number">1</span><br>y := <span class="hljs-number">2</span><br><span class="hljs-keyword">defer</span> calc(<span class="hljs-string">&quot;AA&quot;</span>, x, calc(<span class="hljs-string">&quot;A&quot;</span>, x, y))<br>x = <span class="hljs-number">10</span><br><span class="hljs-keyword">defer</span> calc(<span class="hljs-string">&quot;BB&quot;</span>, x, calc(<span class="hljs-string">&quot;B&quot;</span>, x, y))<br>y = <span class="hljs-number">20</span><br>&#125;<br></code></pre></td></tr></table></figure><p>内置函数介绍<br><strong>close</strong>        主要用来关闭channel<br><strong>len</strong>            用来求长度，比如string、array、slice、map、channel<br><strong>new</strong>            用来分配内存，主要用来分配值类型，比如int、struct。返回的是指针<br><strong>make</strong>        用来分配内存，主要用来分配引用类型，比如chan、map、slice<br><strong>append</strong>        用来追加元素到数组、slice中<br><strong>panic和recover</strong>        用来做错误处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcA</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;func A&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcB</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>err := <span class="hljs-built_in">recover</span>()<br><span class="hljs-comment">//如果程序出出现了panic错误,可以通过recover恢复过来</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;recover in B&quot;</span>)<br>&#125;<br>&#125;()<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;panic in B&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">funcC</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;func C&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>funcA()<br>funcB()<br>funcC()<br>&#125;<br><span class="hljs-built_in">recover</span>()必须搭配<span class="hljs-keyword">defer</span>使用<br><span class="hljs-keyword">defer</span>一定要在可能引发Panic的语句之前定义<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>golang基础学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>「LibreOJ Round</title>
    <link href="/2022/05/04/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/libreoj535/"/>
    <url>/2022/05/04/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/libreoj535/</url>
    
    <content type="html"><![CDATA[<h2 id="「LibreOJ-Round-6」花火"><a href="#「LibreOJ-Round-6」花火" class="headerlink" title="「LibreOJ Round #6」花火"></a>「LibreOJ Round #6」花火</h2><p>题意：$n \leq 300000$的一个排列，每次能交换相邻两个数，并且有一次机会交换不相邻的两个数，可以不用这个机会。问使这个排列升序最少操作几次。</p><p>思路：<br>考虑没有不相邻的话，显然就是逆序对数，对于第二种操作，我们可以把$(i, h_i)$看成平面上的一个点，那么我们只有交换$i, j, i &lt; j且h_i &gt; h_j$的点，才会减少答案，我们把交换的两个点看成一个矩阵，贡献是$sum - 矩阵内点数加上 * 2 -1 + 1$，这个应该不难看出。此外，我们发现如果先做操作一，实质上对于任意操作二的贡献是不变的，不难理解，一次交换后把某点变到矩阵中的话，一定是多付出一次操作次数来换取一个矩阵内部点的增加，最后贡献不变。所以我们先考虑操作二再考虑操作一本质是一样的。</p><p>现在问题变成怎么选择一个数对，使得矩阵中的点数最多，暴力枚举点对+逆序对是$O(n^3logn)$的，显然无法通过本题，我们考虑其实对于一个矩阵来说，他左上角和右下角肯定是越往左上和越往右下越优秀，所以左上角和右下角保留的点一定是满足决策单调性的，分治套个数据结构可以做到$O(nlog^2n)$。</p><p>我们考虑另一种更优的方法，<strong>现在我们想知道$O(n^2)$个矩形，一个矩形最多覆盖多少个点，扫描线有个常见问题是，多个矩形，问哪个点被覆盖最多</strong>，我们希望矩阵覆盖更多的点，对于每个点，考虑他对矩阵的贡献，一个点$(i, h_i)$,设$l$为最小的$h_l &gt; h_i$的数，$r$为最大的$h_r &lt; h_i$的数，那么他对左端点在$[l, i - 1]$和右端点在$[i + 1, r]$的$(i, j)$交换数对有贡献，我们可以把$(i, j)$数对再看成另一个二维平面上的点，那么就变成多个矩形，问哪个点覆盖最多的问题，直接扫描线+线段树即可解决，注意一下进出边顺序即可，时间复杂度$O(nlogn)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> eb emplace_back</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ls p &lt;&lt; 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rs p &lt;&lt; 1 | 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lson p &lt;&lt; 1, l, mid</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> rson p &lt;&lt; 1 | 1, mid + 1, r</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">using</span> ll = <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> maxn = <span class="hljs-number">3e5</span> + <span class="hljs-number">5</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Line</span> &#123;</span><br>    <span class="hljs-keyword">int</span> l, r, op, y;<br>    <span class="hljs-built_in">Line</span>(<span class="hljs-keyword">int</span> m_l, <span class="hljs-keyword">int</span> m_r, <span class="hljs-keyword">int</span> m_op, <span class="hljs-keyword">int</span> m_y) : <span class="hljs-built_in">l</span>(m_l), <span class="hljs-built_in">r</span>(m_r), <span class="hljs-built_in">op</span>(m_op), <span class="hljs-built_in">y</span>(m_y) &#123; &#125;<br>    <span class="hljs-keyword">bool</span> <span class="hljs-keyword">operator</span>&lt;(<span class="hljs-keyword">const</span> Line &amp;x) <span class="hljs-keyword">const</span> &#123;<br>        <span class="hljs-keyword">if</span> (y == x.y)<br>            <span class="hljs-keyword">return</span> op &gt; x.op;<br><br>        <span class="hljs-keyword">return</span> y &lt; x.y;<br>    &#125;<br>&#125;;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BIT</span> &#123;</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> lowb(x) (x&amp;(-x))</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; c;<br>    <span class="hljs-keyword">int</span> N;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        N = n;<br>        c.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = x; i &lt;= N; i += <span class="hljs-built_in">lowb</span>(i)) &#123;<br>            c[i] += val;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = x; i; i -= <span class="hljs-built_in">lowb</span>(i)) &#123;<br>            ans += c[i];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125; bit;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SegmentTree</span> &#123;</span><br>    <span class="hljs-keyword">int</span> mx[maxn &lt;&lt; <span class="hljs-number">2</span>], add[maxn &lt;&lt; <span class="hljs-number">2</span>];<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>        mx[p] = <span class="hljs-built_in">max</span>(mx[ls], mx[rs]);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>        mx[ls] += add[p];<br>        mx[rs] += add[p];<br>        add[ls] += add[p];<br>        add[rs] += add[p];<br>        add[p] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> L, <span class="hljs-keyword">int</span> R, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (L &lt;= l &amp;&amp; r &lt;= R) &#123;<br>            mx[p] += val;<br>            add[p] += val;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (add[p])<br>            <span class="hljs-built_in">pushDown</span>(p);<br><br>        <span class="hljs-keyword">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">if</span> (L &lt;= mid)<br>            <span class="hljs-built_in">update</span>(lson, L, R, val);<br><br>        <span class="hljs-keyword">if</span> (R &gt; mid)<br>            <span class="hljs-built_in">update</span>(rson, L, R, val);<br><br>        <span class="hljs-built_in">pushUp</span>(p);<br>    &#125;<br>&#125; tr;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">lmx</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">rmn</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">h</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        cin &gt;&gt; h[i];<br>    &#125;<br><br>    ll ans = <span class="hljs-number">0</span>;<br>    bit.<span class="hljs-built_in">init</span>(n);<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n; i; --i) &#123;<br>        ans += bit.<span class="hljs-built_in">ask</span>(h[i]);<br>        bit.<span class="hljs-built_in">add</span>(h[i], <span class="hljs-number">1</span>);<br>    &#125;<br><br>    lmx[<span class="hljs-number">1</span>] = h[<span class="hljs-number">1</span>];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; ++i) &#123;<br>        lmx[i] = <span class="hljs-built_in">max</span>(lmx[i - <span class="hljs-number">1</span>], h[i]);<br>    &#125;<br><br>    rmn[n] = h[n];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i; --i) &#123;<br>        rmn[i] = <span class="hljs-built_in">min</span>(rmn[i + <span class="hljs-number">1</span>], h[i]);<br>    &#125;<br><br>    vector&lt;Line&gt; line;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-built_in">lower_bound</span>(lmx.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, lmx.<span class="hljs-built_in">end</span>(), h[i]) - lmx.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">int</span> r = <span class="hljs-built_in">upper_bound</span>(rmn.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, rmn.<span class="hljs-built_in">end</span>(), h[i]) - rmn.<span class="hljs-built_in">begin</span>() - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">if</span> (l &gt;= r || r &lt;= i || l &gt;= i)<br>            <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-comment">//cout &lt;&lt; l &lt;&lt; &quot; &quot; &lt;&lt; i - 1 &lt;&lt; &quot; &quot; &lt;&lt; r &lt;&lt; endl;</span><br>        line.<span class="hljs-built_in">eb</span>(l, i - <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, i + <span class="hljs-number">1</span>);<br>        line.<span class="hljs-built_in">eb</span>(l, i - <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>, r);<br>    &#125;<br><br>    <span class="hljs-built_in">sort</span>(line.<span class="hljs-built_in">begin</span>(), line.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">int</span> mx = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [l, r, op, y] : line) &#123;<br>        mx = <span class="hljs-built_in">max</span>(tr.mx[<span class="hljs-number">1</span>], mx);<br>        tr.<span class="hljs-built_in">update</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, n, l, r, op);<br>    &#125;<br><br>    cout &lt;&lt; ans - <span class="hljs-number">2</span> * mx;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法竞赛</tag>
      
      <tag>线段树</tag>
      
      <tag>扫描线</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go基础学习_2</title>
    <link href="/2022/04/29/golang/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/learn_2/"/>
    <url>/2022/04/29/golang/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/learn_2/</url>
    
    <content type="html"><![CDATA[<h2 id="fmt库"><a href="#fmt库" class="headerlink" title="fmt库"></a>fmt库</h2><p>今天主要讲讲go的fmt标准库</p><p>fmt主要负责输出与输入,区别在于$Print$函数直接输出内容，$Printf$函数支持格式化输出字符串，$Println$函数会在输出内容的结尾添加一个换行符。</p><h3 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h3><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><pre><code class="hljs go">fmt.Print(<span class="hljs-string">&quot;xxx&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, xxx)<br>fmt.Println(<span class="hljs-string">&quot;xx&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="Fprint"><a href="#Fprint" class="headerlink" title="Fprint"></a>Fprint</h3><p>Fprint系列函数会将内容输出到一个io.Writer接口类型的变量w中，我们通常用这个函数往文件中写入内容。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fprint</span><span class="hljs-params">(w io.Writer, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fprintf</span><span class="hljs-params">(w io.Writer, format <span class="hljs-keyword">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fprintln</span><span class="hljs-params">(w io.Writer, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span><br><br>fileObj, err := os.OpenFile(<span class="hljs-string">&quot;./xx.txt&quot;</span>, os.O_CREATE|os.O_WRONLY|os.O_APPEND, <span class="hljs-number">0644</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;打开文件出错，err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>name := <span class="hljs-string">&quot;沙河小王子&quot;</span><br><span class="hljs-comment">// 向打开的文件句柄中写入内容</span><br>fmt.Fprintf(fileObj, <span class="hljs-string">&quot;往文件中写如信息：%s&quot;</span>, name)<br></code></pre></td></tr></table></figure><h3 id="Sprint"><a href="#Sprint" class="headerlink" title="Sprint"></a>Sprint</h3><p>Sprint系列函数会把传入的数据生成并返回一个字符串。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := fmt.Sprint(<span class="hljs-string">&quot;摆了&quot;</span>)<br>name := <span class="hljs-string">&quot;hha&quot;</span><br>age := <span class="hljs-number">17</span><br>s2 := fmt.Sprintf(<span class="hljs-string">&quot;%s %s&quot;</span>, name, age)<br></code></pre></td></tr></table></figure></p><h3 id="Errorf"><a href="#Errorf" class="headerlink" title="Errorf"></a>Errorf</h3><p>Errorf函数根据format参数生成格式化字符串并返回一个包含该字符串的错误。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span><br></code></pre></td></tr></table></figure></p><h2 id="格式化占位符"><a href="#格式化占位符" class="headerlink" title="格式化占位符"></a>格式化占位符</h2><ul><li>通用占位符<br>%v        值的默认格式表示<br>%+v        类似%v，但输出结构体时会添加字段名<br>%#v        值的Go语法表示<br>%T        打印值的类型<br>%%        百分号<br><br/></li><li>bool型占位符<br>%t    true/false<br><br/></li><li>整型（其实和c差不多）<br>%b    表示为二进制<br>%c    该值对应的unicode码值<br>%d    表示为十进制<br>%o    表示为八进制<br>%x    表示为十六进制，使用a-f<br>%X    表示为十六进制，使用A-F<br>%U    表示为Unicode格式：U+1234，等价于”U+%04X”<br>%q    该值对应的单引号括起来的go语法字符字面值，必要时会采用安全的转义表示<br><br/></li><li>浮点数与复数<br>%b    无小数部分、二进制指数的科学计数法，如-123456p-78<br>%e    科学计数法，如-1234.456e+78<br>%E    科学计数法，如-1234.456E+78<br>%f    有小数部分但无指数部分，如123.456<br>%F    等价于%f<br>%g    根据实际情况采用%e或%f格式（以获得更简洁、准确的输出）<br>%G    根据实际情况采用%E或%F格式（以获得更简洁、准确的输出）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go">f := <span class="hljs-number">12.34</span><br>fmt.Printf(<span class="hljs-string">&quot;%b\n&quot;</span>, f)<br>fmt.Printf(<span class="hljs-string">&quot;%e\n&quot;</span>, f)<br>fmt.Printf(<span class="hljs-string">&quot;%E\n&quot;</span>, f)<br>fmt.Printf(<span class="hljs-string">&quot;%f\n&quot;</span>, f)<br>fmt.Printf(<span class="hljs-string">&quot;%g\n&quot;</span>, f)<br>fmt.Printf(<span class="hljs-string">&quot;%G\n&quot;</span>, f)<br><br>f := <span class="hljs-number">12.34</span><br>fmt.Printf(<span class="hljs-string">&quot;%b\n&quot;</span>, f)<br>fmt.Printf(<span class="hljs-string">&quot;%e\n&quot;</span>, f)<br>fmt.Printf(<span class="hljs-string">&quot;%E\n&quot;</span>, f)<br>fmt.Printf(<span class="hljs-string">&quot;%f\n&quot;</span>, f)<br>fmt.Printf(<span class="hljs-string">&quot;%g\n&quot;</span>, f)<br>fmt.Printf(<span class="hljs-string">&quot;%G\n&quot;</span>, f)<br><br><span class="hljs-number">6946802425218990</span>p<span class="hljs-number">-49</span><br><span class="hljs-number">1.234000e+01</span><br><span class="hljs-number">1.234000E+01</span><br><span class="hljs-number">12.340000</span><br><span class="hljs-number">12.34</span><br><span class="hljs-number">12.34</span><br></code></pre></td></tr></table></figure><h2 id="字符串和-byte"><a href="#字符串和-byte" class="headerlink" title="字符串和[]byte"></a>字符串和[]byte</h2><p>%s    直接输出字符串或者[]byte<br>%q    该值对应的双引号括起来的go语法字符串字面值，必要时会采用安全的转义表示<br>%x    每个字节用两字符十六进制数表示（使用a-f<br>%X    每个字节用两字符十六进制数表示（使用A-F）</p><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>%p 0x十六进制下地址</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-number">10</span><br>fmt.Printf(<span class="hljs-string">&quot;%p\n&quot;</span>, &amp;a)<br>fmt.Printf(<span class="hljs-string">&quot;%#p\n&quot;</span>, &amp;a)<br><br><span class="hljs-number">0xc000094000</span><br>c000094000<br></code></pre></td></tr></table></figure><h2 id="宽度标识符"><a href="#宽度标识符" class="headerlink" title="宽度标识符"></a>宽度标识符</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go">%f默认宽度，默认精度<br>%<span class="hljs-number">9</span>f宽度<span class="hljs-number">9</span>，默认精度<br>%<span class="hljs-number">.2</span>f默认宽度，精度<span class="hljs-number">2</span><br>%<span class="hljs-number">9.2</span>f宽度<span class="hljs-number">9</span>，精度<span class="hljs-number">2</span><br>%<span class="hljs-number">9.</span>f宽度<span class="hljs-number">9</span>，精度<span class="hljs-number">0</span><br><br>n := <span class="hljs-number">12.34</span><br>fmt.Printf(<span class="hljs-string">&quot;%f\n&quot;</span>, n)<br>fmt.Printf(<span class="hljs-string">&quot;%9f\n&quot;</span>, n)<br>fmt.Printf(<span class="hljs-string">&quot;%.2f\n&quot;</span>, n)<br>fmt.Printf(<span class="hljs-string">&quot;%9.2f\n&quot;</span>, n)<br>fmt.Printf(<span class="hljs-string">&quot;%9.f\n&quot;</span>, n)<br><br><span class="hljs-number">12.340000</span><br><span class="hljs-number">12.340000</span><br><span class="hljs-number">12.34</span><br>    <span class="hljs-number">12.34</span><br>       <span class="hljs-number">12</span><br></code></pre></td></tr></table></figure><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="fmt-Scan"><a href="#fmt-Scan" class="headerlink" title="fmt.Scan"></a>fmt.Scan</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Scan</span><span class="hljs-params">(a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span><br><br>Scan从标准输入扫描文本，读取由空白符分隔的值保存到传递给本函数的参数中，换行符视为空白符。本函数返回成功扫描的数据个数和遇到的任何错误。如果读取的数据个数比提供的参数少，会返回一个错误报告原因。<br><br>fmt.Scan(&amp;a, &amp;b)<br></code></pre></td></tr></table></figure><h3 id="fmt-Scanf"><a href="#fmt-Scanf" class="headerlink" title="fmt.Scanf"></a>fmt.Scanf</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Scanf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span><br><br>Scanf从标准输入扫描文本，根据format参数指定的格式去读取由空白符分隔的值保存到传递给本函数的参数中。<br>本函数返回成功扫描的数据个数和遇到的任何错误。<br><br>和c的用法一样<br>fmt.Scanf(<span class="hljs-string">&quot;%v %v&quot;</span>, &amp;a, &amp;b)<br></code></pre></td></tr></table></figure><h3 id="fmt-Scanln"><a href="#fmt-Scanln" class="headerlink" title="fmt.Scanln"></a>fmt.Scanln</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Scanln</span><span class="hljs-params">(a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span><br></code></pre></td></tr></table></figure><p>Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。本函数返回成功扫描的数据个数和遇到的任何错误。</p><h2 id="bufio-NewReader"><a href="#bufio-NewReader" class="headerlink" title="bufio.NewReader"></a>bufio.NewReader</h2><p>有时候我们想完整获取输入的内容，而输入的内容可能包含空格，这种情况下可以使用bufio包来实现。示例代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bufioDemo</span><span class="hljs-params">()</span></span> &#123;<br>reader := bufio.NewReader(os.Stdin) <span class="hljs-comment">// 从标准输入生成读对象</span><br>fmt.Print(<span class="hljs-string">&quot;请输入内容：&quot;</span>)<br>text, _ := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>) <span class="hljs-comment">// 读到换行</span><br>text = strings.TrimSpace(text)<br>fmt.Printf(<span class="hljs-string">&quot;%#v\n&quot;</span>, text)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Fscan系列"><a href="#Fscan系列" class="headerlink" title="Fscan系列"></a>Fscan系列</h2><p>这几个函数功能分别类似于fmt.Scan、fmt.Scanf、fmt.Scanln三个函数，只不过它们不是从标准输入中读取数据而是从io.Reader中读取数据。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fscan</span><span class="hljs-params">(r io.Reader, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fscanln</span><span class="hljs-params">(r io.Reader, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fscanf</span><span class="hljs-params">(r io.Reader, format <span class="hljs-keyword">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span><br></code></pre></td></tr></table></figure></p><h2 id="Sscan系列"><a href="#Sscan系列" class="headerlink" title="Sscan系列"></a>Sscan系列</h2><p>这几个函数功能分别类似于fmt.Scan、fmt.Scanf、fmt.Scanln三个函数，只不过它们不是从标准输入中读取数据而是从指定字符串中读取数<br>据。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sscan</span><span class="hljs-params">(str <span class="hljs-keyword">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sscanln</span><span class="hljs-params">(str <span class="hljs-keyword">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sscanf</span><span class="hljs-params">(str <span class="hljs-keyword">string</span>, format <span class="hljs-keyword">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>golang基础学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go基础学习_1</title>
    <link href="/2022/04/28/golang/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/learn_1/"/>
    <url>/2022/04/28/golang/go%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/learn_1/</url>
    
    <content type="html"><![CDATA[<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><figure class="highlight go"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//使用var x type声明并初始化</span><br><span class="hljs-comment">//var 用于声明， 也可以函数内短变量声明 :=</span><br><span class="hljs-comment">//:=等价于 var x type, x = val</span><br><span class="hljs-keyword">var</span> s <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;xx&quot;</span><br><span class="hljs-comment">//自动推导</span><br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&quot;xx&quot;</span><br>s := <span class="hljs-string">&quot;xx&quot;</span><br>name, b, c = <span class="hljs-number">12</span>, <span class="hljs-string">&quot;xx&quot;</span>, <span class="hljs-number">1.0</span><br><br><span class="hljs-comment">//一般这种写法用于全局变量</span><br><span class="hljs-keyword">var</span>(<br>a <span class="hljs-keyword">type</span>, b type2<br>)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>注意在函数内声明的都要被使用，全局则不需要，使用_匿名变量可以接值。</p><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> a [<span class="hljs-keyword">type</span>] = xx<br><span class="hljs-keyword">const</span> &#123;<br>a = xx<br>b = yy<br>&#125;<br><span class="hljs-keyword">const</span> i, j = <span class="hljs-number">2</span>, <span class="hljs-number">3</span><br><br><span class="hljs-comment">//iota可被编译器修改的常量，一开始是0，每一个新的常量声明使iota增加一次</span><br> <span class="hljs-keyword">const</span> (<br>a = <span class="hljs-literal">iota</span>   <span class="hljs-comment">//0</span><br>b          <span class="hljs-comment">//1</span><br>c          <span class="hljs-comment">//2</span><br>d = <span class="hljs-string">&quot;ha&quot;</span>   <span class="hljs-comment">//独立值，iota += 1</span><br>e          <span class="hljs-comment">//&quot;ha&quot;   iota += 1</span><br>f = <span class="hljs-number">100</span>    <span class="hljs-comment">//iota +=1</span><br>g          <span class="hljs-comment">//100  iota +=1</span><br>h = <span class="hljs-literal">iota</span>   <span class="hljs-comment">//7,恢复计数</span><br>i          <span class="hljs-comment">//8</span><br>)<br><span class="hljs-comment">//上述打印0, 1, 2</span><br></code></pre></td></tr></table></figure><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">bool</span><br><span class="hljs-keyword">string</span><br><span class="hljs-keyword">uint8</span>, <span class="hljs-keyword">uint16</span>, <span class="hljs-keyword">uint32</span>, <span class="hljs-keyword">uint64</span><br><span class="hljs-keyword">int8</span>, <span class="hljs-keyword">int16</span>, <span class="hljs-keyword">int32</span>, <span class="hljs-keyword">int64</span><br><span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span><br><span class="hljs-keyword">float32</span>, <span class="hljs-keyword">float64</span><br><span class="hljs-keyword">complex64</span>, <span class="hljs-keyword">complex128</span><br>[<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span><span class="hljs-comment">//数组</span><br>[]<span class="hljs-keyword">int</span> <span class="hljs-comment">//切片</span><br></code></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>go使用”” 或者 `来创建字符串，前者用来创建可解析的字符串而且支持转义，但不能用来引用多行，反引号用来创建原生的字符串字面值，可以由多行构成，但不能转义。双引号用于创建可解析的字符串，反引号则是原生的字符串，用于书写多行消息，html以及正则。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-string">&quot;xx&quot;</span><br>a := <span class="hljs-string">`</span><br><span class="hljs-string">aabb, </span><br><span class="hljs-string">cc</span><br><span class="hljs-string">`</span><br><br>可以使用+=和 +来连接字符串 <br></code></pre></td></tr></table></figure></p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>基本和c++一致，不讲</p><h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">a := <span class="hljs-number">18</span><br><span class="hljs-keyword">if</span> a &gt;= <span class="hljs-number">10</span> &#123;<br><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><br>&#125;<br>注意<span class="hljs-keyword">if</span>里面的<span class="hljs-keyword">bool</span>判断不可以用<span class="hljs-number">0</span>, <span class="hljs-number">1</span>值来判断<br><br>label:<br><span class="hljs-keyword">switch</span>  var1&#123;<br><span class="hljs-keyword">case</span> xx:<br>...<br><span class="hljs-keyword">break</span> label<br><span class="hljs-keyword">case</span> yy:<br>...<br>&#125;<br>注意<span class="hljs-keyword">switch</span>只会跑一个<br><span class="hljs-keyword">fallthrough</span>可以强制做下一个语句<br><span class="hljs-keyword">switch</span> 中加<span class="hljs-keyword">break</span> 可以<span class="hljs-keyword">break</span>到某个标签<br><br></code></pre></td></tr></table></figure><p>同时switch支持多条件匹配<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span><br>...<br>&#125;<br></code></pre></td></tr></table></figure></p><p>流程控制<br>下面这些部分千篇一律，所以只会写与别的语言不一样的地方<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> a := <span class="hljs-number">15</span>; a &gt;= <span class="hljs-number">15</span> &#123;<br><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><br>&#125;<br><br>Go语言中可以使用<span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span>遍历数组、切片、字符串、<span class="hljs-keyword">map</span> 及通道（channel）。 通过<span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span>遍历的返回值有以下规律：<br><br>数组、切片、字符串返回索引和值。<br><span class="hljs-keyword">map</span>返回键和值。<br>通道（channel）只返回通道内的值。<br></code></pre></td></tr></table></figure></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go">[num]<span class="hljs-keyword">type</span><br><span class="hljs-keyword">var</span> a [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-keyword">var</span> b = [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(a); i++ &#123;<br>fmt.Println(a[i])<br>&#125;<br><br><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> a &#123;<br>fmt.Println(val)<br>&#125;<br><br><span class="hljs-comment">// 多维数组</span><br>dp := [<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]<span class="hljs-keyword">string</span>&#123;<br>&#123;<span class="hljs-string">&quot;ss&quot;</span>, <span class="hljs-string">&quot;dd&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;ss&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>&#125;.<br>&#125;<br><br><span class="hljs-keyword">for</span> _, v1 := <span class="hljs-keyword">range</span> dp &#123;<br><span class="hljs-keyword">for</span> _, v2 := <span class="hljs-keyword">range</span> v1 &#123;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意： 多维数组只有第一层可以使用…来让编译器推导数组长度。例如：</strong></p><p>数组是值类型，传参的时候复制整个数组，产生的是副本</p><p>数组支持 “==“、”!=” 操作符，因为内存总是被初始化过的。<br>[n]<em>T表示指针数组，</em>[n]T表示数组指针 。</p><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片（Slice）是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。它非常灵活，支持自动扩容。</p><p>切片是一个引用类型，它的内部结构包含地址、长度和容量。切片一般用于快速地操作一块数据集合。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> name[]<span class="hljs-keyword">type</span><br><span class="hljs-keyword">var</span> name = []<span class="hljs-keyword">type</span>&#123;&#125;<br><br><span class="hljs-built_in">len</span>(name) <span class="hljs-built_in">cap</span>(name)分别求长度和容量<br><br>切片表达式[)<br>[<span class="hljs-number">2</span>:] <span class="hljs-comment">//[2, n)</span><br>[<span class="hljs-number">2</span>:<span class="hljs-number">3</span>] <span class="hljs-comment">//[2, 3 - 1]</span><br>[:<span class="hljs-number">3</span>]<br>[:]<br><br>a := b[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>:<span class="hljs-number">5</span>] [low, high, max]<br><span class="hljs-built_in">cap</span>设置为max - low<br><br><span class="hljs-built_in">make</span>([]T, size, <span class="hljs-built_in">cap</span>)<span class="hljs-comment">//构造结构</span><br></code></pre></td></tr></table></figure><p><strong>切片的本质就是对底层数组的封装，它包含了三个信息：底层数组的指针、切片的长度（len）和切片的容量（cap）。</strong></p><p><strong>切片之间不能比较，数组可以</strong><br><strong>切片为空的时候，要用len(s) == 0判断，不能用nil判断，因为nil值的切片长度和容量都是0，但是我们不能说长度和容量为0的一定是nil</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a []<span class="hljs-keyword">int</span>   <span class="hljs-built_in">len</span> = <span class="hljs-built_in">cap</span> = <span class="hljs-number">0</span>, <span class="hljs-literal">nil</span><br>b := []<span class="hljs-keyword">int</span>&#123;&#125;<span class="hljs-built_in">len</span> = <span class="hljs-built_in">cap</span> = <span class="hljs-number">0</span>, not <span class="hljs-literal">nil</span><br>c := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>)<span class="hljs-built_in">len</span> = <span class="hljs-built_in">cap</span> = <span class="hljs-number">0</span>, not <span class="hljs-literal">nil</span><br></code></pre></td></tr></table></figure><p>切片赋值拷贝后，共用同一个底层数组，对一个切片修改会影响另一个切片的内容。</p><p>遍历同数组一样</p><p><strong>切片添加元素</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> s[]<span class="hljs-keyword">int</span><br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>)<br>s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>s = <span class="hljs-built_in">append</span>(s, s1[<span class="hljs-number">1</span>:<span class="hljs-number">2</span>], s2[<span class="hljs-number">2</span>:<span class="hljs-number">3</span>])<br><br><span class="hljs-comment">//零值切片没必要初始化</span><br><span class="hljs-keyword">var</span> a []<span class="hljs-keyword">int</span><br>a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">1</span>)<br><br><span class="hljs-built_in">append</span>()函数将元素追加到切片的最后并返回该切片。切片numSlice的容量按照<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">4</span>，<span class="hljs-number">8</span>，<span class="hljs-number">16</span>这样的规则自动进行扩容，每次扩容后都是扩容前的<span class="hljs-number">2</span>倍。<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>切片本质上是引用类型，如果直接使用赋值，两者底层地址相同，所以要使用copy</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>b := a<br>b[<span class="hljs-number">0</span>] = <span class="hljs-number">4</span><br>fmt.Println(a)<br>fmt.Println(b)<br><br>c := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>d := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>)<br><span class="hljs-comment">//使用copy复制副本</span><br><span class="hljs-built_in">copy</span>(d, c)<br>fmt.Println(b)<br>fmt.Println(c)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><p>从切片中删除元素<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//删除索引为2</span><br>a = <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">2</span>], a[<span class="hljs-number">3</span>:])<br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs go">定义<br><span class="hljs-keyword">map</span>[key]val<br>a := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>, <span class="hljs-number">8</span>)<br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span><br><br>a := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">int</span>&#123;&#125;<br><br>遍历的话有两种方式<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> a &#123;<br><br>&#125;<br><br><span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> a &#123;<br><br>&#125;<br><br><span class="hljs-built_in">delete</span>(<span class="hljs-keyword">map</span>, key) <span class="hljs-comment">//删除某个key</span><br><br><span class="hljs-comment">//注意 go底层的map是基于hash table的，所以是无序的</span><br><br>元素为<span class="hljs-keyword">map</span>类型的切片<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> mapSlice = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>, <span class="hljs-number">3</span>)<br><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> mapSlice &#123;<br>fmt.Printf(<span class="hljs-string">&quot;index:%d value:%v\n&quot;</span>, index, value)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;after init&quot;</span>)<br><span class="hljs-comment">// 对切片中的map元素进行初始化</span><br>mapSlice[<span class="hljs-number">0</span>] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>, <span class="hljs-number">10</span>)<br>mapSlice[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;小王子&quot;</span><br>mapSlice[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;password&quot;</span>] = <span class="hljs-string">&quot;123456&quot;</span><br>mapSlice[<span class="hljs-number">0</span>][<span class="hljs-string">&quot;address&quot;</span>] = <span class="hljs-string">&quot;沙河&quot;</span><br><span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> mapSlice &#123;<br>fmt.Printf(<span class="hljs-string">&quot;index:%d value:%v\n&quot;</span>, index, value)<br>&#125;<br>&#125;<br><br>值为切片类型的<span class="hljs-keyword">map</span><br><span class="hljs-keyword">var</span> slicemap = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>][]<span class="hljs-keyword">string</span>, <span class="hljs-number">3</span>)<br>v, ok := slicemap[key]<br><span class="hljs-keyword">if</span> !ok &#123;<br>v = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>golang基础学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/27/hello-world/"/>
    <url>/2022/04/27/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>大学</tag>
      
      <tag>大学2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test_my_site</title>
    <link href="/2022/01/15/test-my-site/"/>
    <url>/2022/01/15/test-my-site/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
